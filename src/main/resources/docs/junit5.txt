1.
Три уровня тестирования
- unit testing - тестирование маленького компонента приложения (как правило функции) в изоляции от других компонентов
- integration testing - тестирование нескольких компонентов
- acceptance testing - или функциональное тестирование всего приложения в целом (приложение как черный ящик)

jUnit5 разбит на модули
- jUnit platform - запуск тестов и интеграция с другими платформами (gradle, maven, eclipse, idea и т.д.)
- jUnit Jupiter - непосредственно разработка тестов
- jUnit Vintage - интеграция с предыдущими версиями jUnit

Требует java 8 и выше
Плагины для мавена
- maven-compiler-plugin - для какой версии компилировать тесты
- maven-surefire-plugin - запуск тестов

установка wrapper-а
https://maven.apache.org/wrapper/index.html
мавеном из идеи (правое меню maven, кнопка "m") команда
        mvn wrapper:wrapper
В терминале Idea mvnw использует Java из JAVA_HOME. Соответственно классы должны быть скомпилированы этой версией
(в настройках проекта может быть другая версия)

2. LifeCycle
@BeforeAll/@AfterAll - один раз перед вызовом тестового класса. По умолчанию
        TestInstance.Lifecycle.PER_METHOD
Это означает, что перед вызовом каждого тестового метода будет создаваться новый объект тестового класса.
Поэтому метод, помеченный @BeforeAll/@AfterAll должен быть статическим
Для изменения такого поведения класс должен быть помечен аннотацией
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)

3. Test Launcher
Тест могут писаться как на jUnit5 так и на jUnit4. Но какждый jUnit имете свой engine для запуска тестов.
Чтобы была возможность одновременного использования существует junit-platform-engine API (соответствующая библиотека)
Тесты запускаются посредством maven, gradle, idea. Для этого они используют библиотеку junit-platform-launcher.
Используя ее можно написать свой лаунчер

4. Tags
Запуск тестов помеченных определенным тегом
    mvn clean test -Dgroups=full
    mvn clean test -Dgroups=user
    mvn clean test -DexcludedGroups=user

5. Order
По умолчанию порядок вызова тестовых методов случаен и хорошей практикой является написание независимых тестов.
Однако есть возможность задать порядок.
Для этого тестовый класс помечается аннотацией @TestMethodOrder с параметром типа MethodOrderer.class
- OrderAnnotation. Тестовый методы помечаются аннотацией Order
- MethodName. Сортировка по названию метода
- DisplayName. Одноименная аннотация с названием теста
- Random

@Nested - позволяет группировать тесты с использованием внутренних классов

6. Dependency injection
Механизм появился в jUnit5 как и параметризованные конструкторы тестовых классов.
Параметры могут принимать и методы.
За внедрение отвечает ParameterResolver
- supportsParameter метод должен возвращать true если требуемый параметр соответствует текущему ParameterResolver
- resolveParameter возвращает параметр
 parameterContext - информация от требуемом методе, extensionContext - информация о вызываемом классе/методе
Классы, реализующие ParameterResolver - singleton-ы

@ExtendWith - реализует механизм, позволяющий добавлять дополнительный функционал к тестам

7. Parameterized tests
Модуль junit-jupiter-params
Аннотация @ParameterizedTest работает в паре с  @ArgumentsSource, которая предоставляет провайдера данных
@NullSource, @EmptySource, @ValueSource предоставляют только один параметр

8. Extension model
Test life cycle callbacks - позволяет внедрится на любом этапе жизненного цикла тестов
Test instance postprocessing - вызывается после создания объекта тестового класса
Condition test execution - создание условий на выполнения тестов. Вызывается первым пред созданием теста
Parameter resolution - внедрение параметров
Exception handing - Обработка исключительных ситуаций во время выполнения тестов

Обработчик должен реализовать интерфейс Extension
На каждый вариант модели есть набор интерфейсов
BeforeAllCallback/AfterAllCallback, BeforeEachCallback/BeforeEachCallback и т.д.
TestInstancePostProcessor
ExecutionCondition
ParameterResolver
TestExecutionExceptionHandler

ExtensionContext содержит в себе всю информацию о выполняемом тесте

9. Mockito
Фреймворк, позволяющий делать заглушки на зависимые объекты

Выражение - Mockito.mock(T.class) - возвращает объект переданного типа, в котором методы переопределены
и возвращают дефолтные значения (для объектов Null, чисел 0, boolean - false, коллекций - пустые экземпляры коллекций)
или определенные к коде (Stab)
        Mockito.doReturn(...).when()
Для этого объекта instanceof T вернет true. Для понимания является ли это mock объект или обычный с точки зрения
Mockito позволяет Mockito.mockingDetails
По сути это объект класса с новой реализацией (используется библиотека ByteBuddy).
Передавать в Mockito.mock можно интерфейс.
mock объект можно создать и для классов с исключительно приватными конструкторами типа синглтонов и утилитных классов,
а при минимальной настройке фреймворка — и перечислений (enums).

Mockito.verify - проверка вызова метода (один или заданно кол-ва раз - параметр VerificationMode)
Mockito.inOrder - проверка вызова методов в определенном порядке
Mockito.when(...).thenThrow(Exception) - если метод может вернуть исключение, можно проверить как он будет обработан

spy
    Mockito.spy(T.class)

Спай-объекты - mock, которые в основном ведут себя как обычные объекты, но позволяют переопределять поведение отдельных методов.
Используются когда нужно тестировать реальный объект, но при этом изменить поведение некоторых его частей.
Т.е. если возвращаемое значение метода не переопределено, будет вызываться метод реального объекта.

В отличие от mock'ов, их можно создавать на основе как класса, так и готового объекта.
При создании spy на основе класса, если его тип — интерфейс, будет создан обычный mock-объект,
а если тип — класс, то Mockito попытается создать экземпляр при помощи конструктора по умолчанию (без параметров).
И только если такого конструктора нет, произойдёт ошибка и тест не сработает.