1.
Три уровня тестирования
- unit testing - тестирование маленького компонента приложения (как правило функции) в изоляции от других компонентов
- integration testing - тестирование нескольких компонентов
- acceptance testing - или функциональное тестирование всего приложения в целом (приложение как черный ящик)

jUnit5 разбит на модули
- jUnit platform - запуск тестов и интеграция с другими платформами (gradle, maven, eclipse, idea и т.д.)
- jUnit Jupiter - непосредственно разработка тестов
- jUnit Vintage - интеграция с предыдущими версиями jUnit

Требует java 8 и выше
Плагины для мавена
- maven-compiler-plugin - для какой версии компилировать тесты
- maven-surefire-plugin - запуск тестов

установка wrapper-а
https://maven.apache.org/wrapper/index.html
мавеном из идеи (правое меню maven, кнопка "m") команда
        mvn wrapper:wrapper
В терминале Idea mvnw использует Java из JAVA_HOME. Соответственно классы должны быть скомпилированы этой версией
(в настройках проекта может быть другая версия)

2. LifeCycle
@BeforeAll/@AfterAll - один раз перед вызовом тестового класса. По умолчанию
        TestInstance.Lifecycle.PER_METHOD
Это означает, что перед вызовом каждого тестового метода будет создаваться новый объект тестового класса.
Поэтому метод, помеченный @BeforeAll/@AfterAll должен быть статическим
Для изменения такого поведения класс должен быть помечен аннотацией
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)

3. Test Launcher
Тест могут писаться как на jUnit5 так и на jUnit4. Но какждый jUnit имете свой engine для запуска тестов.
Чтобы была возможность одновременного использования существует junit-platform-engine API (соответствующая библиотека)
Тесты запускаются посредством maven, gradle, idea. Для этого они используют библиотеку junit-platform-launcher.
Используя ее можно написать свой лаунчер

4. Tags
Запуск тестов помеченных определенным тегом
    mvn clean test -Dgroups=full
    mvn clean test -Dgroups=user
    mvn clean test -DexcludedGroups=user

5. Order
По умолчанию порядок вызова тестовых методов случаен и хорошей практикой является написание независимых тестов.
Однако есть возможность задать порядок.
Для этого тестовый класс помечается аннотацией @TestMethodOrder с параметром типа MethodOrderer.class
- OrderAnnotation. Тестовый методы помечаются аннотацией Order
- MethodName. Сортировка по названию метода
- DisplayName. Одноименная аннотация с названием теста
- Random

@Nested - позволяет группировать тесты с использованием внутренних классов

6. Dependency injection
Механизм появился в jUnit5 как и параметризованные конструкторы тестовых классов.
Параметры могут принимать и методы.
За внедрение отвечает ParameterResolver
- supportsParameter метод должен возвращать true если требуемый параметр соответствует текущему ParameterResolver
- resolveParameter возвращает параметр
 parameterContext - информация от требуемом методе, extensionContext - информация о вызываемом классе/методе
Классы, реализующие ParameterResolver - singleton-ы

@ExtendWith - реализует механизм, позволяющий добавлять дополнительный функционал к тестам

7. Parameterized tests
Модуль junit-jupiter-params
Аннотация @ParameterizedTest работает в паре с  @ArgumentsSource, которая предоставляет провайдера данных
@NullSource, @EmptySource, @ValueSource предоставляют только один параметр